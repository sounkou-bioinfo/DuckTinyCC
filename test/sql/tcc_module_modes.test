# name: test/sql/tcc_module_modes.test
# description: clean codegen API coverage for tcc_module
# group: [ducktinycc]

require ducktinycc

query TTTT
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'config_set', runtime_path := '/tmp/runtime-a');
----
true	config_set	OK	/tmp/runtime-a

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'config_get');
----
true	config_get	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'config_reset');
----
true	config_reset	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'list');
----
true	list	OK

query I
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END
FROM tcc_system_paths();
----
1

query I
SELECT CASE WHEN SUM(CASE WHEN kind = 'runtime' THEN 1 ELSE 0 END) >= 1 THEN 1 ELSE 0 END
FROM tcc_system_paths();
----
1

query I
SELECT CASE WHEN SUM(CASE WHEN kind = 'resolved' AND exists THEN 1 ELSE 0 END) >= 1 THEN 1 ELSE 0 END
FROM tcc_library_probe(library := 'libtcc1.a');
----
1

query I
SELECT CASE WHEN SUM(CASE WHEN kind = 'resolved' AND exists THEN 1 ELSE 0 END) = 0 THEN 1 ELSE 0 END
FROM tcc_library_probe(library := '__ducktinycc_missing_lib__');
----
1

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'register');
----
false	register	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'ffi_load');
----
false	ffi_load	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'load');
----
false	load	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'unregister');
----
false	unregister	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'nonsense');
----
false	nonsense	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'new_state');
----
false	new_state	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'bind');
----
false	bind	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_compile');
----
false	tinycc_compile	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'tcc_new_state');
----
true	tcc_new_state	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_source',
  source := 'long long add2(long long x){ return x + 2; }'
);
----
true	add_source	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'tinycc_bind',
  symbol := 'add2',
  sql_name := 'add2'
);
----
true	tinycc_bind	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'compile', return_type := 'i64', arg_types := ['i64']);
----
true	compile	OK

query I
SELECT add2(40);
----
42

query I
SELECT CASE WHEN detail LIKE '%ducktinycc_register_signature%' THEN 1 ELSE 0 END
FROM tcc_module(
  mode := 'codegen_preview',
  symbol := 'add2',
  sql_name := 'add2_preview',
  return_type := 'i64',
  arg_types := ['i64']
);
----
1

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'codegen_preview',
  symbol := 'add2',
  sql_name := 'add2_preview_bad',
  return_type := 'json',
  arg_types := ['i64']
);
----
false	codegen_preview	E_BAD_SIGNATURE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'codegen_preview',
  symbol := 'add2',
  sql_name := 'add2_preview_bad_mode',
  return_type := 'i64',
  arg_types := ['i64'],
  wrapper_mode := 'arrow'
);
----
false	codegen_preview	E_BAD_WRAPPER_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int add_i32(int a, int b){ return a + b; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
----
true	quick_compile	OK

query I
SELECT add_i32(20, 22);
----
42

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int add_i32(int a, int b){ return a + b + 1; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
----
false	quick_compile	E_INIT_FAILED

query I
SELECT add_i32(20, 22);
----
42

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := '#include <math.h>
double qpow(double x, double y){ return pow(x, y); }',
  symbol := 'qpow',
  sql_name := 'qpow',
  return_type := 'f64',
  arg_types := ['f64', 'f64'],
  include_path := 'third_party/tinycc/include',
  library_path := 'third_party/tinycc',
  library := 'm'
);
----
true	quick_compile	OK

query I
SELECT CAST(qpow(2.0, 5.0) AS BIGINT);
----
32

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := '_Bool gt0(long long x){ return x > 0; }',
  symbol := 'gt0',
  sql_name := 'gt0',
  return_type := 'bool',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query TT
SELECT gt0(3), gt0(-1);
----
true	false

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'double half(double x){ return x / 2.0; }',
  symbol := 'half',
  sql_name := 'half',
  return_type := 'f64',
  arg_types := ['f64']
);
----
true	quick_compile	OK

query I
SELECT CAST(half(8.0) AS BIGINT);
----
4

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'void touch(int x){ (void)x; }',
  symbol := 'touch',
  sql_name := 'touch',
  return_type := 'void',
  arg_types := ['i32']
);
----
true	quick_compile	OK

query T
SELECT touch(5);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'tcc_new_state');
----
true	tcc_new_state	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'add_library', library := 'm');
----
true	add_library	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_source',
  source := '#include <math.h>
double pwr(double x, double y){ return pow(x, y); }'
);
----
true	add_source	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'tinycc_bind',
  symbol := 'pwr',
  sql_name := 'pwr'
);
----
true	tinycc_bind	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'compile', return_type := 'f64', arg_types := ['f64', 'f64']);
----
true	compile	OK

query I
SELECT CAST(pwr(2.0, 5.0) AS BIGINT);
----
32

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long bad(long long x){ return x; }',
  symbol := 'bad',
  sql_name := 'bad',
  return_type := 'json',
  arg_types := ['i64']
);
----
false	quick_compile	E_BAD_SIGNATURE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long too_many(long long a0,long long a1,long long a2,long long a3,long long a4,long long a5,long long a6,long long a7,long long a8,long long a9,long long a10){ return a0 + a10; }',
  symbol := 'too_many',
  sql_name := 'too_many',
  return_type := 'i64',
  arg_types := ['i64','i64','i64','i64','i64','i64','i64','i64','i64','i64','i64']
);
----
true	quick_compile	OK

query I
SELECT too_many(1,2,3,4,5,6,7,8,9,10,11);
----
12

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'const char *echo_cstr(const char *s){ return s; }',
  symbol := 'echo_cstr',
  sql_name := 'echo_cstr',
  return_type := 'varchar',
  arg_types := ['cstring']
);
----
true	quick_compile	OK

query TT
SELECT echo_cstr('duck'), echo_cstr('abcdefghijklmnopqrstuvwxyz0123456789');
----
duck	abcdefghijklmnopqrstuvwxyz0123456789

query T
SELECT echo_cstr(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'const char *empty_to_null(const char *s){ if (!s || s[0] == 0) return 0; return s; }',
  symbol := 'empty_to_null',
  sql_name := 'empty_to_null',
  return_type := 'text',
  arg_types := ['string']
);
----
true	quick_compile	OK

query TT
SELECT empty_to_null('ok'), empty_to_null('');
----
ok	NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'const char *batch_echo(const char *s){ return s; }',
  symbol := 'batch_echo',
  sql_name := 'batch_echo',
  return_type := 'varchar',
  arg_types := ['varchar'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TTT
SELECT batch_echo(a), batch_echo(b), batch_echo(c)
FROM (SELECT 'x' AS a, 'yy' AS b, NULL AS c);
----
x	yy	NULL

query T
SELECT batch_echo('abcdefghijklmnopqrstuvwxyz0123456789');
----
abcdefghijklmnopqrstuvwxyz0123456789

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'unsigned long long blob_len(ducktinycc_blob_t b){ return b.ptr ? b.len : 0ULL; }',
  symbol := 'blob_len',
  sql_name := 'blob_len',
  return_type := 'u64',
  arg_types := ['blob']
);
----
true	quick_compile	OK

query I
SELECT CAST(blob_len(from_hex('DEADBEEF')) AS BIGINT);
----
4

query T
SELECT blob_len(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_blob_t blob_echo(ducktinycc_blob_t b){ return b; }',
  symbol := 'blob_echo',
  sql_name := 'blob_echo',
  return_type := 'bytea',
  arg_types := ['varbinary']
);
----
true	quick_compile	OK

query T
SELECT hex(blob_echo(from_hex('00FF10')));
----
00FF10

query T
SELECT blob_echo(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_blob_t batch_blob_echo(ducktinycc_blob_t b){ return b; }',
  symbol := 'batch_blob_echo',
  sql_name := 'batch_blob_echo',
  return_type := 'buffer',
  arg_types := ['bytes'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TT
SELECT hex(batch_blob_echo(from_hex('ABCD'))), batch_blob_echo(NULL) IS NULL;
----
ABCD	true

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_date_t next_day(ducktinycc_date_t d){ d.days += 1; return d; }',
  symbol := 'next_day',
  sql_name := 'next_day',
  return_type := 'date',
  arg_types := ['date']
);
----
true	quick_compile	OK

query T
SELECT next_day(DATE '2024-01-01');
----
2024-01-02

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_time_t add_second_time(ducktinycc_time_t t){ t.micros += 1000000; return t; }',
  symbol := 'add_second_time',
  sql_name := 'add_second_time',
  return_type := 'time',
  arg_types := ['time']
);
----
true	quick_compile	OK

query T
SELECT add_second_time(TIME '01:02:03');
----
01:02:04

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_timestamp_t add_second_ts(ducktinycc_timestamp_t t){ t.micros += 1000000; return t; }',
  symbol := 'add_second_ts',
  sql_name := 'add_second_ts',
  return_type := 'timestamp',
  arg_types := ['timestamp']
);
----
true	quick_compile	OK

query T
SELECT add_second_ts(TIMESTAMP '2024-01-01 00:00:00');
----
2024-01-01 00:00:01

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long interval_days(ducktinycc_interval_t v){ return (long long)v.days; }',
  symbol := 'interval_days',
  sql_name := 'interval_days',
  return_type := 'i64',
  arg_types := ['interval']
);
----
true	quick_compile	OK

query I
SELECT interval_days(INTERVAL '3 days 5 hours');
----
3

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_hugeint_t uuid_echo(ducktinycc_hugeint_t u){ return u; }',
  symbol := 'uuid_echo',
  sql_name := 'uuid_echo',
  return_type := 'uuid',
  arg_types := ['uuid']
);
----
true	quick_compile	OK

query T
SELECT uuid_echo('00000000-0000-0000-0000-00000000000a'::UUID) = '00000000-0000-0000-0000-00000000000a'::UUID;
----
true

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_decimal_t decimal_echo(ducktinycc_decimal_t d){ return d; }',
  symbol := 'decimal_echo',
  sql_name := 'decimal_echo',
  return_type := 'decimal',
  arg_types := ['decimal']
);
----
true	quick_compile	OK

query T
SELECT decimal_echo(12.345::DECIMAL(18,3)) = 12.345::DECIMAL(18,3);
----
true

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_i64(ducktinycc_list_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_list_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_i64',
  sql_name := 'sum_i64',
  return_type := 'i64',
  arg_types := ['i64[]']
);
----
true	quick_compile	OK

query I
SELECT sum_i64([1,2,3]::BIGINT[]);
----
6

query I
SELECT sum_i64([1,NULL,3]::BIGINT[]);
----
4

query T
SELECT sum_i64(NULL::BIGINT[]);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_i64_batch(ducktinycc_list_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_list_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_i64_batch',
  sql_name := 'sum_i64_batch',
  return_type := 'i64',
  arg_types := ['list_i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query T
SELECT CAST(sum_i64_batch(v) AS VARCHAR)
FROM (VALUES ([1,2]::BIGINT[]), ([3,NULL,4]::BIGINT[]), (NULL::BIGINT[])) t(v);
----
3
7
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_list_t make_pair_list(long long x){
  static long long values[2];
  static uint64_t validity[1];
  ducktinycc_list_t out;
  values[0] = x;
  values[1] = x + 1;
  validity[0] = 1ULL;
  out.ptr = values;
  out.validity = validity;
  out.offset = 0;
  out.len = 2;
  return out;
}',
  symbol := 'make_pair_list',
  sql_name := 'make_pair_list',
  return_type := 'i64[]',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query T
SELECT CAST(make_pair_list(10) AS VARCHAR);
----
[10, NULL]

query T
SELECT make_pair_list(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_list_t batch_echo_list(ducktinycc_list_t a){ return a; }',
  symbol := 'batch_echo_list',
  sql_name := 'batch_echo_list',
  return_type := 'i64[]',
  arg_types := ['i64[]'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query T
SELECT CAST(batch_echo_list(v) AS VARCHAR)
FROM (VALUES ([1,2]::BIGINT[]), ([3,NULL,5]::BIGINT[]), (NULL::BIGINT[])) t(v);
----
[1, 2]
[3, NULL, 5]
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_array3(ducktinycc_array_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_array_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_array3',
  sql_name := 'sum_array3',
  return_type := 'i64',
  arg_types := ['i64[3]']
);
----
true	quick_compile	OK

query I
SELECT sum_array3([1,2,3]::BIGINT[3]);
----
6

query I
SELECT sum_array3([1,NULL,3]::BIGINT[3]);
----
4

query T
SELECT sum_array3(NULL::BIGINT[3]);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_array_t make_array3(long long x){
  static long long values[3];
  static uint64_t validity[1];
  ducktinycc_array_t out;
  values[0] = x;
  values[1] = x + 1;
  values[2] = x + 2;
  validity[0] = 5ULL;
  out.ptr = values;
  out.validity = validity;
  out.offset = 0;
  out.len = 3;
  return out;
}',
  symbol := 'make_array3',
  sql_name := 'make_array3',
  return_type := 'i64[3]',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query T
SELECT CAST(make_array3(10) AS VARCHAR);
----
[10, NULL, 12]

query T
SELECT make_array3(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_array_t batch_echo_array3(ducktinycc_array_t a){ return a; }',
  symbol := 'batch_echo_array3',
  sql_name := 'batch_echo_array3',
  return_type := 'i64[3]',
  arg_types := ['i64[3]'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query T
SELECT CAST(batch_echo_array3(v) AS VARCHAR)
FROM (VALUES ([1,2,3]::BIGINT[3]), ([4,NULL,6]::BIGINT[3]), (NULL::BIGINT[3])) t(v);
----
[1, 2, 3]
[4, NULL, 6]
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long batch_add(long long a, long long b){ return a + b; }',
  symbol := 'batch_add',
  sql_name := 'batch_add',
  return_type := 'i64',
  arg_types := ['i64','i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query I
SELECT CAST(SUM(batch_add(i, 2)) AS BIGINT)
FROM range(1000) AS t(i);
----
501500

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long batch_double(long long x){ return x * 2; }',
  symbol := 'batch_double',
  sql_name := 'batch_double',
  return_type := 'i64',
  arg_types := ['i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TT
SELECT batch_double(NULL), batch_double(21);
----
NULL	42

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'void batch_touch(long long x){ (void)x; }',
  symbol := 'batch_touch',
  sql_name := 'batch_touch',
  return_type := 'void',
  arg_types := ['i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query I
SELECT COUNT(*)::BIGINT
FROM range(128) AS t(i)
WHERE batch_touch(i) IS NULL;
----
128

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long bad_wrapper(long long x){ return x; }',
  symbol := 'bad_wrapper',
  sql_name := 'bad_wrapper',
  return_type := 'i64',
  arg_types := ['i64'],
  wrapper_mode := 'arrow'
);
----
false	quick_compile	E_BAD_WRAPPER_MODE
