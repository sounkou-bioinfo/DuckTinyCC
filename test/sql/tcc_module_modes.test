# name: test/sql/tcc_module_modes.test
# description: clean codegen API coverage for tcc_module
# group: [ducktinycc]

require ducktinycc

query TTTT
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'config_set', runtime_path := '/tmp/runtime-a');
----
true	config_set	OK	/tmp/runtime-a

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'config_get');
----
true	config_get	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'config_reset');
----
true	config_reset	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'list');
----
true	list	OK

query I
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END
FROM tcc_system_paths();
----
1

query I
SELECT CASE WHEN SUM(CASE WHEN kind = 'runtime' THEN 1 ELSE 0 END) >= 1 THEN 1 ELSE 0 END
FROM tcc_system_paths();
----
1

query I
SELECT CASE WHEN SUM(CASE WHEN kind = 'resolved' AND exists THEN 1 ELSE 0 END) >= 1 THEN 1 ELSE 0 END
FROM tcc_library_probe(library := 'libtcc1.a');
----
1

query I
SELECT CASE WHEN SUM(CASE WHEN kind = 'resolved' AND exists THEN 1 ELSE 0 END) = 0 THEN 1 ELSE 0 END
FROM tcc_library_probe(library := '__ducktinycc_missing_lib__');
----
1

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'register');
----
false	register	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'ffi_load');
----
false	ffi_load	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'load');
----
false	load	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'unregister');
----
false	unregister	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'nonsense');
----
false	nonsense	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'new_state');
----
false	new_state	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'bind');
----
false	bind	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_compile');
----
false	tinycc_compile	E_BAD_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'tcc_new_state');
----
true	tcc_new_state	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_source',
  source := 'long long add2(long long x){ return x + 2; }'
);
----
true	add_source	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'tinycc_bind',
  symbol := 'add2',
  sql_name := 'add2'
);
----
true	tinycc_bind	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'compile', return_type := 'i64', arg_types := ['i64']);
----
true	compile	OK

query I
SELECT add2(40);
----
42

query I
SELECT CASE WHEN detail LIKE '%ducktinycc_register_signature%' THEN 1 ELSE 0 END
FROM tcc_module(
  mode := 'codegen_preview',
  symbol := 'add2',
  sql_name := 'add2_preview',
  return_type := 'i64',
  arg_types := ['i64']
);
----
1

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'codegen_preview',
  symbol := 'add2',
  sql_name := 'add2_preview_bad',
  return_type := 'json',
  arg_types := ['i64']
);
----
false	codegen_preview	E_BAD_SIGNATURE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'codegen_preview',
  symbol := 'add2',
  sql_name := 'add2_preview_bad_mode',
  return_type := 'i64',
  arg_types := ['i64'],
  wrapper_mode := 'arrow'
);
----
false	codegen_preview	E_BAD_WRAPPER_MODE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int add_i32(int a, int b){ return a + b; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
----
true	quick_compile	OK

query I
SELECT add_i32(20, 22);
----
42

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int add_i32(int a, int b){ return a + b + 1; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
----
false	quick_compile	E_INIT_FAILED

query I
SELECT add_i32(20, 22);
----
42

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := '#include <math.h>
double qpow(double x, double y){ return pow(x, y); }',
  symbol := 'qpow',
  sql_name := 'qpow',
  return_type := 'f64',
  arg_types := ['f64', 'f64'],
  include_path := 'third_party/tinycc/include',
  library_path := 'third_party/tinycc',
  library := 'm'
);
----
true	quick_compile	OK

query I
SELECT CAST(qpow(2.0, 5.0) AS BIGINT);
----
32

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := '_Bool gt0(long long x){ return x > 0; }',
  symbol := 'gt0',
  sql_name := 'gt0',
  return_type := 'bool',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query TT
SELECT gt0(3), gt0(-1);
----
true	false

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'double half(double x){ return x / 2.0; }',
  symbol := 'half',
  sql_name := 'half',
  return_type := 'f64',
  arg_types := ['f64']
);
----
true	quick_compile	OK

query I
SELECT CAST(half(8.0) AS BIGINT);
----
4

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'void touch(int x){ (void)x; }',
  symbol := 'touch',
  sql_name := 'touch',
  return_type := 'void',
  arg_types := ['i32']
);
----
true	quick_compile	OK

query T
SELECT touch(5);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'tcc_new_state');
----
true	tcc_new_state	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'add_library', library := 'm');
----
true	add_library	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_source',
  source := '#include <math.h>
double pwr(double x, double y){ return pow(x, y); }'
);
----
true	add_source	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'tinycc_bind',
  symbol := 'pwr',
  sql_name := 'pwr'
);
----
true	tinycc_bind	OK

query TTT
SELECT ok, mode, code
FROM tcc_module(mode := 'compile', return_type := 'f64', arg_types := ['f64', 'f64']);
----
true	compile	OK

query I
SELECT CAST(pwr(2.0, 5.0) AS BIGINT);
----
32

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long bad(long long x){ return x; }',
  symbol := 'bad',
  sql_name := 'bad',
  return_type := 'json',
  arg_types := ['i64']
);
----
false	quick_compile	E_BAD_SIGNATURE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long too_many(long long a0,long long a1,long long a2,long long a3,long long a4,long long a5,long long a6,long long a7,long long a8,long long a9,long long a10){ return a0 + a10; }',
  symbol := 'too_many',
  sql_name := 'too_many',
  return_type := 'i64',
  arg_types := ['i64','i64','i64','i64','i64','i64','i64','i64','i64','i64','i64']
);
----
true	quick_compile	OK

query I
SELECT too_many(1,2,3,4,5,6,7,8,9,10,11);
----
12

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'const char *echo_cstr(const char *s){ return s; }',
  symbol := 'echo_cstr',
  sql_name := 'echo_cstr',
  return_type := 'varchar',
  arg_types := ['cstring']
);
----
true	quick_compile	OK

query TT
SELECT echo_cstr('duck'), echo_cstr('abcdefghijklmnopqrstuvwxyz0123456789');
----
duck	abcdefghijklmnopqrstuvwxyz0123456789

query T
SELECT echo_cstr(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'const char *empty_to_null(const char *s){ if (!s || s[0] == 0) return 0; return s; }',
  symbol := 'empty_to_null',
  sql_name := 'empty_to_null',
  return_type := 'text',
  arg_types := ['string']
);
----
true	quick_compile	OK

query TT
SELECT empty_to_null('ok'), empty_to_null('');
----
ok	NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'const char *batch_echo(const char *s){ return s; }',
  symbol := 'batch_echo',
  sql_name := 'batch_echo',
  return_type := 'varchar',
  arg_types := ['varchar'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TTT
SELECT batch_echo(a), batch_echo(b), batch_echo(c)
FROM (SELECT 'x' AS a, 'yy' AS b, NULL AS c);
----
x	yy	NULL

query T
SELECT batch_echo('abcdefghijklmnopqrstuvwxyz0123456789');
----
abcdefghijklmnopqrstuvwxyz0123456789

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'unsigned long long blob_len(ducktinycc_blob_t b){ return b.ptr ? b.len : 0ULL; }',
  symbol := 'blob_len',
  sql_name := 'blob_len',
  return_type := 'u64',
  arg_types := ['blob']
);
----
true	quick_compile	OK

query I
SELECT CAST(blob_len(from_hex('DEADBEEF')) AS BIGINT);
----
4

query T
SELECT blob_len(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_blob_t blob_echo(ducktinycc_blob_t b){ return b; }',
  symbol := 'blob_echo',
  sql_name := 'blob_echo',
  return_type := 'bytea',
  arg_types := ['varbinary']
);
----
true	quick_compile	OK

query T
SELECT hex(blob_echo(from_hex('00FF10')));
----
00FF10

query T
SELECT blob_echo(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_blob_t batch_blob_echo(ducktinycc_blob_t b){ return b; }',
  symbol := 'batch_blob_echo',
  sql_name := 'batch_blob_echo',
  return_type := 'buffer',
  arg_types := ['bytes'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TT
SELECT hex(batch_blob_echo(from_hex('ABCD'))), batch_blob_echo(NULL) IS NULL;
----
ABCD	true

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_date_t next_day(ducktinycc_date_t d){ d.days += 1; return d; }',
  symbol := 'next_day',
  sql_name := 'next_day',
  return_type := 'date',
  arg_types := ['date']
);
----
true	quick_compile	OK

query T
SELECT next_day(DATE '2024-01-01');
----
2024-01-02

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_time_t add_second_time(ducktinycc_time_t t){ t.micros += 1000000; return t; }',
  symbol := 'add_second_time',
  sql_name := 'add_second_time',
  return_type := 'time',
  arg_types := ['time']
);
----
true	quick_compile	OK

query T
SELECT add_second_time(TIME '01:02:03');
----
01:02:04

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_timestamp_t add_second_ts(ducktinycc_timestamp_t t){ t.micros += 1000000; return t; }',
  symbol := 'add_second_ts',
  sql_name := 'add_second_ts',
  return_type := 'timestamp',
  arg_types := ['timestamp']
);
----
true	quick_compile	OK

query T
SELECT add_second_ts(TIMESTAMP '2024-01-01 00:00:00');
----
2024-01-01 00:00:01

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long interval_days(ducktinycc_interval_t v){ return (long long)v.days; }',
  symbol := 'interval_days',
  sql_name := 'interval_days',
  return_type := 'i64',
  arg_types := ['interval']
);
----
true	quick_compile	OK

query I
SELECT interval_days(INTERVAL '3 days 5 hours');
----
3

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_hugeint_t uuid_echo(ducktinycc_hugeint_t u){ return u; }',
  symbol := 'uuid_echo',
  sql_name := 'uuid_echo',
  return_type := 'uuid',
  arg_types := ['uuid']
);
----
true	quick_compile	OK

query T
SELECT uuid_echo('00000000-0000-0000-0000-00000000000a'::UUID) = '00000000-0000-0000-0000-00000000000a'::UUID;
----
true

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_decimal_t decimal_echo(ducktinycc_decimal_t d){ return d; }',
  symbol := 'decimal_echo',
  sql_name := 'decimal_echo',
  return_type := 'decimal',
  arg_types := ['decimal']
);
----
true	quick_compile	OK

query T
SELECT decimal_echo(12.345::DECIMAL(18,3)) = 12.345::DECIMAL(18,3);
----
true

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_i64(ducktinycc_list_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_list_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_i64',
  sql_name := 'sum_i64',
  return_type := 'i64',
  arg_types := ['i64[]']
);
----
true	quick_compile	OK

query I
SELECT sum_i64([1,2,3]::BIGINT[]);
----
6

query I
SELECT sum_i64([1,NULL,3]::BIGINT[]);
----
4

query T
SELECT sum_i64(NULL::BIGINT[]);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_i64_batch(ducktinycc_list_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_list_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_i64_batch',
  sql_name := 'sum_i64_batch',
  return_type := 'i64',
  arg_types := ['list_i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query T
SELECT CAST(sum_i64_batch(v) AS VARCHAR)
FROM (VALUES ([1,2]::BIGINT[]), ([3,NULL,4]::BIGINT[]), (NULL::BIGINT[])) t(v);
----
3
7
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_list_t make_pair_list(long long x){
  static long long values[2];
  static uint64_t validity[1];
  ducktinycc_list_t out;
  values[0] = x;
  values[1] = x + 1;
  validity[0] = 1ULL;
  out.ptr = values;
  out.validity = validity;
  out.offset = 0;
  out.len = 2;
  return out;
}',
  symbol := 'make_pair_list',
  sql_name := 'make_pair_list',
  return_type := 'i64[]',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query T
SELECT CAST(make_pair_list(10) AS VARCHAR);
----
[10, NULL]

query T
SELECT make_pair_list(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_list_t batch_echo_list(ducktinycc_list_t a){ return a; }',
  symbol := 'batch_echo_list',
  sql_name := 'batch_echo_list',
  return_type := 'i64[]',
  arg_types := ['i64[]'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query T
SELECT CAST(batch_echo_list(v) AS VARCHAR)
FROM (VALUES ([1,2]::BIGINT[]), ([3,NULL,5]::BIGINT[]), (NULL::BIGINT[])) t(v);
----
[1, 2]
[3, NULL, 5]
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_array3(ducktinycc_array_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_array_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_array3',
  sql_name := 'sum_array3',
  return_type := 'i64',
  arg_types := ['i64[3]']
);
----
true	quick_compile	OK

query I
SELECT sum_array3([1,2,3]::BIGINT[3]);
----
6

query I
SELECT sum_array3([1,NULL,3]::BIGINT[3]);
----
4

query T
SELECT sum_array3(NULL::BIGINT[3]);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_array_t make_array3(long long x){
  static long long values[3];
  static uint64_t validity[1];
  ducktinycc_array_t out;
  values[0] = x;
  values[1] = x + 1;
  values[2] = x + 2;
  validity[0] = 5ULL;
  out.ptr = values;
  out.validity = validity;
  out.offset = 0;
  out.len = 3;
  return out;
}',
  symbol := 'make_array3',
  sql_name := 'make_array3',
  return_type := 'i64[3]',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query T
SELECT CAST(make_array3(10) AS VARCHAR);
----
[10, NULL, 12]

query T
SELECT make_array3(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_array_t batch_echo_array3(ducktinycc_array_t a){ return a; }',
  symbol := 'batch_echo_array3',
  sql_name := 'batch_echo_array3',
  return_type := 'i64[3]',
  arg_types := ['i64[3]'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query T
SELECT CAST(batch_echo_array3(v) AS VARCHAR)
FROM (VALUES ([1,2,3]::BIGINT[3]), ([4,NULL,6]::BIGINT[3]), (NULL::BIGINT[3])) t(v);
----
[1, 2, 3]
[4, NULL, 6]
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long struct_sum2(ducktinycc_struct_t s){
  const long long *a;
  const long long *b;
  long long out = 0;
  if (!s.field_ptrs || s.field_count < 2) return 0;
  a = (const long long *)ducktinycc_struct_field_ptr(&s, 0);
  b = (const long long *)ducktinycc_struct_field_ptr(&s, 1);
  if (a && ducktinycc_struct_field_is_valid(&s, 0)) out += a[s.offset];
  if (b && ducktinycc_struct_field_is_valid(&s, 1)) out += b[s.offset];
  return out;
}',
  symbol := 'struct_sum2',
  sql_name := 'struct_sum2',
  return_type := 'i64',
  arg_types := ['struct<a:i64;b:i64>']
);
----
true	quick_compile	OK

query I
SELECT struct_sum2({'a': 2::BIGINT, 'b': 5::BIGINT}::STRUCT(a BIGINT, b BIGINT));
----
7

query I
SELECT struct_sum2({'a': 2::BIGINT, 'b': NULL::BIGINT}::STRUCT(a BIGINT, b BIGINT));
----
2

query T
SELECT struct_sum2(NULL::STRUCT(a BIGINT, b BIGINT));
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_struct_t make_pair_struct(long long x){
  static long long a[1];
  static long long b[1];
  static uint64_t va[1];
  static uint64_t vb[1];
  static const void *ptrs[2];
  static const uint64_t *validity[2];
  ducktinycc_struct_t out;
  a[0] = x;
  b[0] = x + 1;
  va[0] = 1ULL;
  vb[0] = 0ULL;
  ptrs[0] = a;
  ptrs[1] = b;
  validity[0] = va;
  validity[1] = vb;
  out.field_ptrs = ptrs;
  out.field_validity = validity;
  out.field_count = 2;
  out.offset = 0;
  return out;
}',
  symbol := 'make_pair_struct',
  sql_name := 'make_pair_struct',
  return_type := 'struct<a:i64;b:i64>',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query TT
SELECT CAST((make_pair_struct(10)).a AS VARCHAR), CAST((make_pair_struct(10)).b AS VARCHAR);
----
10	NULL

query T
SELECT make_pair_struct(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_struct_t batch_echo_struct(ducktinycc_struct_t s){ return s; }',
  symbol := 'batch_echo_struct',
  sql_name := 'batch_echo_struct',
  return_type := 'struct<a:i64;b:i64>',
  arg_types := ['struct<a:i64;b:i64>'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TT
SELECT CAST((batch_echo_struct(v)).a AS VARCHAR), CAST((batch_echo_struct(v)).b AS VARCHAR)
FROM (
  VALUES
    ({'a': 1::BIGINT, 'b': 2::BIGINT}::STRUCT(a BIGINT, b BIGINT)),
    ({'a': 3::BIGINT, 'b': NULL::BIGINT}::STRUCT(a BIGINT, b BIGINT))
) t(v);
----
1	2
3	NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long map_sum(ducktinycc_map_t m){
  const long long *k = (const long long *)m.key_ptr;
  const long long *v = (const long long *)m.value_ptr;
  unsigned long long i;
  long long out = 0;
  if (!m.key_ptr || !m.value_ptr) return 0;
  for (i = 0; i < m.len; i++) {
    if (ducktinycc_map_key_is_valid(&m, i) && ducktinycc_map_value_is_valid(&m, i)) {
      out += k[i] + v[i];
    }
  }
  return out;
}',
  symbol := 'map_sum',
  sql_name := 'map_sum',
  return_type := 'i64',
  arg_types := ['map<i64;i64>']
);
----
true	quick_compile	OK

query I
SELECT map_sum(MAP([1::BIGINT,2::BIGINT],[10::BIGINT,20::BIGINT])::MAP(BIGINT,BIGINT));
----
33

query I
SELECT map_sum(MAP([1::BIGINT,2::BIGINT],[10::BIGINT,NULL::BIGINT])::MAP(BIGINT,BIGINT));
----
11

query T
SELECT map_sum(NULL::MAP(BIGINT,BIGINT));
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_map_t make_map2(long long x){
  static long long keys[2];
  static long long values[2];
  static uint64_t key_validity[1];
  static uint64_t value_validity[1];
  ducktinycc_map_t out;
  keys[0] = 1;
  keys[1] = 2;
  values[0] = x;
  values[1] = x + 1;
  key_validity[0] = 3ULL;
  value_validity[0] = 1ULL;
  out.key_ptr = keys;
  out.key_validity = key_validity;
  out.value_ptr = values;
  out.value_validity = value_validity;
  out.offset = 0;
  out.len = 2;
  return out;
}',
  symbol := 'make_map2',
  sql_name := 'make_map2',
  return_type := 'map<i64;i64>',
  arg_types := ['i64']
);
----
true	quick_compile	OK

query TT
SELECT CAST(map_extract_value(make_map2(10), 1) AS VARCHAR), CAST(map_extract_value(make_map2(10), 2) AS VARCHAR);
----
10	NULL

query T
SELECT make_map2(NULL);
----
NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'ducktinycc_map_t batch_echo_map(ducktinycc_map_t m){ return m; }',
  symbol := 'batch_echo_map',
  sql_name := 'batch_echo_map',
  return_type := 'map<i64;i64>',
  arg_types := ['map<i64;i64>'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TT
SELECT CAST(map_extract_value(batch_echo_map(v), 1) AS VARCHAR), CAST(map_extract_value(batch_echo_map(v), 2) AS VARCHAR)
FROM (
  VALUES
    (MAP([1::BIGINT,2::BIGINT],[5::BIGINT,6::BIGINT])::MAP(BIGINT,BIGINT)),
    (MAP([1::BIGINT,2::BIGINT],[7::BIGINT,NULL::BIGINT])::MAP(BIGINT,BIGINT))
) t(v);
----
5	6
7	NULL

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long bad_struct(ducktinycc_struct_t s){ (void)s; return 0; }',
  symbol := 'bad_struct',
  sql_name := 'bad_struct',
  return_type := 'i64',
  arg_types := ['struct<a:varchar>']
);
----
false	quick_compile	E_BAD_SIGNATURE

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long batch_add(long long a, long long b){ return a + b; }',
  symbol := 'batch_add',
  sql_name := 'batch_add',
  return_type := 'i64',
  arg_types := ['i64','i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query I
SELECT CAST(SUM(batch_add(i, 2)) AS BIGINT)
FROM range(1000) AS t(i);
----
501500

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long batch_double(long long x){ return x * 2; }',
  symbol := 'batch_double',
  sql_name := 'batch_double',
  return_type := 'i64',
  arg_types := ['i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query TT
SELECT batch_double(NULL), batch_double(21);
----
NULL	42

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'void batch_touch(long long x){ (void)x; }',
  symbol := 'batch_touch',
  sql_name := 'batch_touch',
  return_type := 'void',
  arg_types := ['i64'],
  wrapper_mode := 'batch'
);
----
true	quick_compile	OK

query I
SELECT COUNT(*)::BIGINT
FROM range(128) AS t(i)
WHERE batch_touch(i) IS NULL;
----
128

query TTT
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long bad_wrapper(long long x){ return x; }',
  symbol := 'bad_wrapper',
  sql_name := 'bad_wrapper',
  return_type := 'i64',
  arg_types := ['i64'],
  wrapper_mode := 'arrow'
);
----
false	quick_compile	E_BAD_WRAPPER_MODE
