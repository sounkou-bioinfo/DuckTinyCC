---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# DuckTinyCC

DuckTinyCC is a DuckDB C extension with a `tcc_*` SQL surface for TinyCC-based
in-process C scripting workflows.

## API Surface

All functionality is exposed through `tcc_module(...)` and selected with
`mode := ...`.  
Every mode returns one diagnostics row with `ok`, `code`, `message`, and
context columns.

### Session and Configuration

| Mode | Purpose | Notes |
|---|---|---|
| `config_get` | Show current session configuration | Includes runtime path and counters |
| `config_set` | Set session runtime path | Connection-scoped |
| `config_reset` | Reset runtime path and build state | Keeps extension loaded |
| `tcc_new_state` | Start a fresh build state | Drops staged build inputs |
| `list` | Show session registry/build counters | Diagnostics only |

### Build Inputs

| Mode | Purpose |
|---|---|
| `add_include`, `add_sysinclude` | Add include paths |
| `add_library_path`, `add_library` | Add library paths/libraries |
| `add_option`, `add_define` | Add compiler flags and defines |
| `add_header`, `add_source` | Stage C code units in session |
| `tinycc_bind` | Stage `symbol` + `sql_name` for next compile |

### Compile, Load, and Registry

| Mode | Purpose | Notes |
|---|---|---|
| `compile`, `tinycc_compile` | Compile staged session code and register SQL UDF | Uses `tinycc_bind` or explicit `symbol`/`sql_name` |
| `register` | Compile provided `source` and register SQL UDF | One-shot registration |
| `ffi_load` | Generate C loader + register SQL UDF | Rtinycc-style dynamic codegen path |
| `load` | Compile and execute module init symbol | Manual dynamic module path |
| `unregister` | Remove artifact metadata from session registry | Loaded/codegen modules are pinned (`E_UNSAFE_UNLOAD`) |

## Supported Types

Type metadata is explicit for `compile`, `tinycc_compile`, `register`, and
`ffi_load`:

- `return_type := ...` is required
- `arg_types := [...]` is required (use `[]` for zero arguments)

Current executable SQL registration support:

| Signature Piece | Accepted Tokens | DuckDB Type |
|---|---|---|
| `return_type` | `i64`, `bigint`, `longlong` | `BIGINT` |
| each `arg_types` element | `i64`, `bigint`, `longlong` | `BIGINT` |

Additional limits and behavior:

- Arity: `0..10` arguments
- NULL handling: NULL-in/NULL-out on the generated BIGINT wrappers
- `return_type := 'void'` is parsed but not currently executable in the SQL
  registration path (`E_UNSUPPORTED_SIGNATURE`)

## Build

```sh
make configure
make debug
```

## Test

```sh
make test_debug
make test_release
```

## Examples

The examples below use `DBI` + `duckdb` and run end-to-end against the built extension.

### Setup

This chunk connects to DuckDB in-memory and loads the extension artifact.

```{r eval=TRUE}
library(DBI)
library(duckdb)

drv <- duckdb::duckdb(config = list(allow_unsigned_extensions = "true"))
con <- dbConnect(drv, dbdir = ":memory:")
ext_path <- normalizePath("build/release/ducktinycc.duckdb_extension", mustWork = FALSE)
dbExecute(con, sprintf("LOAD '%s'", ext_path))
```

### Session Configuration

This chunk exercises `config_set`, `config_get`, and `list` before compilation work starts.  
It intentionally sets `runtime_path := ''` so TinyCC uses the extension-managed default runtime location.

```{r eval=TRUE}
dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'config_set',
    runtime_path := ''
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'config_get')
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'list')
")
```

### Build State 1: Session Build Inputs

This chunk starts a fresh state, adds include/sysinclude/library paths, options, defines, headers, and source code.  
It then binds and compiles two different functions from the same state and calls both via plain SQL.

```{r eval=TRUE}
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'tcc_new_state')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_include', include_path := 'third_party/tinycc/include')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_sysinclude', sysinclude_path := 'third_party/tinycc/include')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_library_path', library_path := 'third_party/tinycc')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_option', option := '-O2')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_define', define_name := 'TCC_SHIFT', define_value := '3')")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'add_header',
    header := '#include <stdint.h>'
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'add_source',
    source := '
      long long tcc_add_shift(long long x){ return x + TCC_SHIFT; }
      long long tcc_times2(long long x){ return x * 2; }
    '
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_add_shift', sql_name := 'tcc_add_shift')
")
dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(
    mode := 'tinycc_compile',
    return_type := 'i64',
    arg_types := ['i64']
  )
")
dbGetQuery(con, "SELECT tcc_add_shift(39) AS value")

dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_times2', sql_name := 'tcc_times2')
")
dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(
    mode := 'compile',
    return_type := 'i64',
    arg_types := ['i64']
  )
")
dbGetQuery(con, "SELECT tcc_times2(21) AS value")
```

### Build State 2: FFI Codegen and SQL Invocation

This chunk exercises the dynamic C codegen path (`ffi_load`) and then calls the registered SQL function normally.

```{r eval=TRUE}
dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(
    mode := 'ffi_load',
    source := 'long long tcc_add10(long long x){ return x + 10; }',
    symbol := 'tcc_add10',
    sql_name := 'tcc_add10',
    return_type := 'i64',
    arg_types := ['i64']
  )
")

dbGetQuery(con, "SELECT tcc_add10(32) AS value")
```

### Unregister and Reset

This final chunk exercises `unregister`, `list`, and `config_reset`.
Because loaded/codegen modules are pinned for safety, `unregister` returns `E_UNSAFE_UNLOAD`.

```{r eval=TRUE}
dbGetQuery(con, "SELECT ok, mode, code FROM tcc_module(mode := 'unregister', sql_name := 'tcc_add_shift')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'list')")
dbGetQuery(con, "SELECT ok, mode, code FROM tcc_module(mode := 'config_reset')")
```

### Cleanup

This chunk closes the database connection.

```{r eval=TRUE}
dbDisconnect(con, shutdown = TRUE)
```

## Notes

- Function invocation is plain SQL (`SELECT my_udf(...)`) after `compile`/`register`/`load`/`ffi_load`.
- Dynamic module mode (`mode := 'load'`) keeps compiled TinyCC state alive and can use host helper symbols such as `ducktinycc_register_i64_unary`.
- Dynamic FFI codegen mode (`mode := 'ffi_load'`) generates a C loader module and registers SQL functions via host helpers.
- All outputs are returned as a diagnostics table for SQL-native observability.
