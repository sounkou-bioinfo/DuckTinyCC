---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# DuckTinyCC

DuckTinyCC is a DuckDB C extension with a `tcc_*` SQL surface for TinyCC-based
in-process C scripting workflows.

## API Surface

All functionality is exposed through `tcc_module(...)` and selected with
`mode := ...`.  
Every mode returns one diagnostics row with `ok`, `code`, `message`, and
context columns.

### Session and Configuration

| Mode | Purpose | Notes |
|---|---|---|
| `config_get` | Show current session configuration | Includes runtime path and counters |
| `config_set` | Set session runtime path | Connection-scoped |
| `config_reset` | Reset runtime path and build state | Keeps extension loaded |
| `tcc_new_state` | Start a fresh build state | Drops staged build inputs |
| `list` | Show session registry/build counters | Diagnostics only |

### Build Inputs

| Mode | Purpose |
|---|---|
| `add_include`, `add_sysinclude` | Add include paths |
| `add_library_path`, `add_library` | Add library paths/libraries |
| `add_option`, `add_define` | Add compiler flags and defines |
| `add_header`, `add_source` | Stage C code units in session |
| `tinycc_bind` | Stage `symbol` + `sql_name` for next compile |

### Compile and Register

| Mode | Purpose | Notes |
|---|---|---|
| `compile` | Compile staged session code and register SQL UDF | Uses `tinycc_bind` or explicit `symbol`/`sql_name` |
| `quick_compile` | One-shot fast lane compile + register | Requires `source`, `symbol`, `sql_name`, `return_type`, `arg_types`; can also pass per-call `include_path`, `sysinclude_path`, `library_path`, `library`, `option`, `define_*`, `header` |
| `codegen_preview` | Generate wrapper C source only (no compile/relocate/register) | Uses same signature inputs as compile path; returns generated C in `detail` |

### Discovery Helpers

| Function | Purpose | Notes |
|---|---|---|
| `tcc_system_paths(runtime_path := '', library_path := '')` | Show include and library search paths used by TinyCC workflows | Includes existence flags; includes Windows/MSYS2/Rtools defaults on Windows builds |
| `tcc_library_probe(library := ..., runtime_path := '', library_path := '')` | Resolve a library short name or full filename/path | Supports `.a`, `.so*`, `.dylib`, `.dll`, `.lib` style names |

## Supported Types

Type metadata is explicit for `compile`, `quick_compile`, and `codegen_preview`:

- `return_type := ...` is required
- `arg_types := [...]` is required (use `[]` for zero arguments)

Current executable SQL registration support:

| Signature Piece | Accepted Tokens | DuckDB Type |
|---|---|---|
| `return_type` | `void`, `bool`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `f32`, `f64` | `BIGINT` for `void`; otherwise matching scalar type |
| each `arg_types` element | `bool`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `f32`, `f64` | matching scalar type |

Additional limits and behavior:

- Arity: `0..N` arguments (no fixed hard-coded cap)
- NULL handling: NULL-in/NULL-out
- `void` return registers as a SQL function that emits `NULL` values

## How It Works (Current)

- `compile`, `quick_compile`, and `codegen_preview` generate C wrapper code around the target `symbol`.
- Generated wrappers use a typed row ABI (`void **args`, `out_value`, `out_is_null`), unpack inputs, call the C symbol, and write back the result.
- A generated module init function calls `ducktinycc_register_signature(...)` to register the SQL scalar UDF in the active DuckDB connection.
- TinyCC compile + relocate is fully in-memory (no shared library file is emitted).
- Host symbols injected into each TinyCC state are currently fixed: `duckdb_ext_api` and `ducktinycc_register_signature`.
- Execution uses DuckDB vectors but invokes the generated wrapper row-by-row inside the scalar UDF loop.

## Design Direction (API Still Evolving)

- Host symbol registration mode: feasible and aligned with Rtinycc-style embedding; prefer an allow-listed registry (name -> host address) over raw SQL-provided addresses.
- Arrow to reduce marshalling: not used in the current scalar UDF path; DuckDB already provides columnar vectors, and remaining overhead is mainly per-row wrapper calls.
- Structs: usable inside compiled C code today, but not yet first-class SQL argument/return types.
- Pointers: best exposed as `UBIGINT` handles with helper functions and type/ownership tags, rather than untyped raw pointer values.

## Builds

```sh
make configure
make debug  # debug
make release # release
```

## Test

```sh
make test_debug
make test_release
```

## Examples

Run these snippets in one DuckDB shell session (`duckdb -unsigned`) with timing
enabled.

### 1) Setup

```sh
duckdb -unsigned
.timer on
LOAD 'build/release/ducktinycc.duckdb_extension';
```

### 2) Session Configuration

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'config_set',
  runtime_path := ''
);

SELECT ok, mode, code, detail
FROM tcc_module(mode := 'config_get');

SELECT ok, mode, code, detail
FROM tcc_module(mode := 'list');
SQL
```

### 3) System Paths and Library Probe Helpers

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT kind, key, exists, value
FROM tcc_system_paths()
LIMIT 12;

SELECT kind, key, exists, value, detail
FROM tcc_library_probe(library := 'libtcc1.a');
SQL
```

### 4) Example A: Staged Build + `tinycc_bind` + `compile`

This example stages shared build inputs once, compiles two symbols, and calls both SQL functions.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'tcc_new_state');
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_include',
  include_path := 'third_party/tinycc/include'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_sysinclude',
  sysinclude_path := 'third_party/tinycc/include'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_library_path',
  library_path := 'third_party/tinycc'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_option',
  option := '-O2'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_define',
  define_name := 'TCC_SHIFT',
  define_value := '3'
);

SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_header',
  header := '#include <stdint.h>'
);

SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_source',
  source := '
    long long tcc_add_shift(long long x){ return x + TCC_SHIFT; }
    long long tcc_times2(long long x){ return x * 2; }
  '
);

SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_add_shift', sql_name := 'tcc_add_shift');
SELECT ok, mode, code
FROM tcc_module(
  mode := 'compile',
  return_type := 'i64',
  arg_types := ['i64']
);
SELECT tcc_add_shift(39) AS value;

SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_times2', sql_name := 'tcc_times2');
SELECT ok, mode, code
FROM tcc_module(
  mode := 'compile',
  return_type := 'i64',
  arg_types := ['i64']
);
SELECT tcc_times2(21) AS value;
SQL
```

### 5) Example B: Fast Lane `quick_compile` (with include/library inputs)

This example compiles and registers directly from one SQL call, including
`include_path`, `library_path`, and `library`.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := '#include <math.h>
double qpow(double x, double y){ return pow(x, y); }',
  symbol := 'qpow',
  sql_name := 'qpow',
  return_type := 'f64',
  arg_types := ['f64', 'f64'],
  include_path := 'third_party/tinycc/include',
  library_path := 'third_party/tinycc',
  library := 'm'
);
SELECT CAST(qpow(2.0, 5.0) AS BIGINT) AS value;
SQL
```

### 6) Example C: Libraries (`add_library`)

This example links `libm`, compiles a function that uses `pow`, then calls it.
The required C header is included in the source unit.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(mode := 'tcc_new_state');
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_library',
  library := 'm'
);
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_source',
  source := '#include <math.h>
double pwr(double x, double y){ return pow(x, y); }'
);
SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_bind', symbol := 'pwr', sql_name := 'pwr');
SELECT ok, mode, code
FROM tcc_module(mode := 'compile', return_type := 'f64', arg_types := ['f64', 'f64']);
SELECT CAST(pwr(2.0, 5.0) AS BIGINT) AS value;
SQL
```

### 7) Reset Session

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'list');
SELECT ok, mode, code
FROM tcc_module(mode := 'config_reset');
SQL
```

### 8) Codegen Preview (No Compile)

This shows generated wrapper/module-init source without compiling or registering
the SQL function.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, phase, code, artifact_id, LEFT(detail, 220) AS preview
FROM tcc_module(
  mode := 'codegen_preview',
  source := 'int add_i32(int a, int b){ return a + b; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
SQL
```

### 9) `config_reset` Semantics

`config_reset` clears runtime/build staging state, but does not remove already
registered SQL UDF catalog entries.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int reset_demo(int x){ return x + 1; }',
  symbol := 'reset_demo',
  sql_name := 'reset_demo',
  return_type := 'i32',
  arg_types := ['i32']
);
SELECT reset_demo(41) AS before_reset;

SELECT ok, mode, code
FROM tcc_module(mode := 'config_reset');
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'list');

SELECT reset_demo(41) AS after_reset;
SQL
```

### 10) CLI Benchmark Snippet

Use the DuckDB CLI timer to benchmark compile and call latency quickly:

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
.timer on
LOAD 'build/release/ducktinycc.duckdb_extension';
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int add_i32(int a, int b){ return a + b; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
SELECT add_i32(20, 22);
SELECT SUM(add_i32(i::INTEGER, 42::INTEGER)) AS s FROM range(1000000) t(i);
SELECT SUM(add_i32(i::INTEGER, 42::INTEGER)) AS s FROM range(1000000) t(i);
SELECT SUM(add_i32(i::INTEGER, 42::INTEGER)) AS s FROM range(1000000) t(i);
SQL
```

### 11) Cleanup

No explicit cleanup is required in the CLI example flow.

## Notes

- Function invocation is plain SQL (`SELECT my_udf(...)`) after `compile` or `quick_compile`.
- `add_header`/`add_source` are compiled as separate translation units. For external library prototypes, include headers directly in the relevant `source` unit.
- Use `tcc_system_paths()` and `tcc_library_probe()` to diagnose platform-specific library resolution (including Windows/Rtools/MSYS2 layouts).
- All outputs are returned as a diagnostics table for SQL-native observability.
