---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# DuckTinyCC

DuckTinyCC is a DuckDB C extension with a `tcc_*` SQL surface for TinyCC-based
in-process C scripting workflows.

## Functions

| Function | Description | Notes |
|---|---|---|
| `tcc_module(mode := 'config_get', ...)` | Show current session configuration | Returns diagnostics table |
| `tcc_module(mode := 'config_set', runtime_path := ... )` | Set session runtime path | Connection-scoped state |
| `tcc_module(mode := 'config_reset', ...)` | Reset session configuration | Falls back to default runtime path |
| `tcc_module(mode := 'tcc_new_state', ...)` | Start a fresh TinyCC build state | Keeps connection/runtime scope |
| `tcc_module(mode := 'add_include'/'add_sysinclude'/'add_library_path'/'add_library', ...)` | Add TinyCC include/library inputs | Session-scoped build inputs |
| `tcc_module(mode := 'add_option'/'add_define'/'add_header'/'add_source', ...)` | Add compile options/defines/code units | Session-scoped build inputs |
| `tcc_module(mode := 'tinycc_bind', symbol := ..., sql_name := ...)` | Bind symbol + sql alias for next compile | Rtinycc-style bind step |
| `tcc_module(mode := 'list', ...)` | Show current registry/session counters | Diagnostics table |
| `tcc_module(mode := 'compile'/'tinycc_compile', ...)` | Compile + relocate from current session and store callable artifact | Fresh `tcc_new` per compile |
| `tcc_module(mode := 'call', source := ..., symbol := ..., arg_bigint := ...)` | Compile + execute `BIGINT(BIGINT)` symbol | One-shot compile+execute |
| `tcc_module(mode := 'register', source := ..., symbol := ..., sql_name := ...)` | Compile unit and store callable artifact in session registry | Uses fresh TinyCC state per registration |
| `tcc_module(mode := 'call', sql_name := ..., arg_bigint := ...)` | Execute previously registered artifact | No recompile on call path |
| `tcc_module(mode := 'unregister', sql_name := ...)` | Remove a registered artifact from session registry | Frees TinyCC state |

## Build

```sh
make configure
make debug
```

## Test

```sh
make test_debug
make test_release
```

## Examples

The examples below use `DBI` + `duckdb` and run end-to-end against the built extension.

### Setup

This chunk connects to DuckDB in-memory and loads the extension artifact.

```{r eval=TRUE}
library(DBI)
library(duckdb)

drv <- duckdb::duckdb(config = list(allow_unsigned_extensions = "true"))
con <- dbConnect(drv, dbdir = ":memory:")
ext_path <- normalizePath("build/release/ducktinycc.duckdb_extension", mustWork = FALSE)
dbExecute(con, sprintf("LOAD '%s'", ext_path))
```

### Session Configuration

This chunk exercises `config_set`, `config_get`, and `list` before compilation work starts.  
It intentionally sets `runtime_path := ''` so TinyCC uses the extension-managed default runtime location.

```{r eval=TRUE}
dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'config_set',
    runtime_path := ''
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'config_get')
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'list')
")
```

### Build State 1: Multiple Inputs and Functions

This chunk starts a fresh state, adds include/sysinclude/library paths, options, defines, headers, and source code.  
It then binds and compiles two different functions from the same state and calls both.

```{r eval=TRUE}
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'tcc_new_state')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_include', include_path := 'third_party/tinycc/include')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_sysinclude', sysinclude_path := 'third_party/tinycc/include')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_library_path', library_path := 'third_party/tinycc')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_option', option := '-O2')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'add_define', define_name := 'TCC_SHIFT', define_value := '3')")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'add_header',
    header := '#include <stdint.h>'
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'add_source',
    source := '
      long long tcc_add_shift(long long x){ return x + TCC_SHIFT; }
      long long tcc_times2(long long x){ return x * 2; }
    '
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_add_shift', sql_name := 'tcc_add_shift')
")
dbGetQuery(con, "SELECT ok, mode, code FROM tcc_module(mode := 'tinycc_compile')")
dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'call', sql_name := 'tcc_add_shift', arg_bigint := '39')
")

dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_times2', sql_name := 'tcc_times2')
")
dbGetQuery(con, "SELECT ok, mode, code FROM tcc_module(mode := 'compile')")
dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'call', sql_name := 'tcc_times2', arg_bigint := '21')
")
```

### Build State 2: Explicit Register Mode and One-Shot Call

This chunk exercises `register` directly and also the one-shot `call` path with inline source.  
It confirms both pre-registered and ephemeral compilation paths in one session.

```{r eval=TRUE}
dbGetQuery(con, "
  SELECT ok, mode, code
  FROM tcc_module(
    mode := 'register',
    source := 'long long tcc_add10(long long x){ return x + 10; }',
    symbol := 'tcc_add10',
    sql_name := 'tcc_add10'
  )
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(mode := 'call', sql_name := 'tcc_add10', arg_bigint := '32')
")

dbGetQuery(con, "
  SELECT ok, mode, code, detail
  FROM tcc_module(
    mode := 'call',
    source := 'long long tcc_square(long long x){ return x * x; }',
    symbol := 'tcc_square',
    arg_bigint := '9'
  )
")
```

### Unregister and Reset

This final chunk exercises `unregister`, `list`, and `config_reset`.

```{r eval=TRUE}
dbGetQuery(con, "SELECT ok, mode, code FROM tcc_module(mode := 'unregister', sql_name := 'tcc_add10')")
dbGetQuery(con, "SELECT ok, mode, code, detail FROM tcc_module(mode := 'list')")
dbGetQuery(con, "SELECT ok, mode, code FROM tcc_module(mode := 'config_reset')")
```

### Cleanup

This chunk closes the database connection.

```{r eval=TRUE}
dbDisconnect(con, shutdown = TRUE)
```

## Notes

- Current callable execution path is `mode := 'call'` with `BIGINT(BIGINT)` function signatures.
- Dynamic runtime registration as standalone DuckDB scalar names from inside `tcc_module` is not enabled in this build; artifacts are session-registered and invoked with `mode := 'call'`.
- All outputs are returned as a diagnostics table for SQL-native observability.
