---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# DuckTinyCC

`DuckTinyCC` is a `DuckDB` `C` extension for in-process JIT compiled C UDFs allowing `C` scripting via `TinyCC`. Combined with `C` parsing facilities offered by for example the [`sitting duck extension`](https://github.com/teaguesterling/sitting_duck), we can quickly generate declarative bindings.

## API Surface

All functionality is exposed through `tcc_module(...)` and selected with
`mode := ...`.  
Every mode returns one diagnostics row with `ok`, `code`, `message`, and
context columns. Functions are prefixed by `tcc_`

### Session and Configuration

| Mode | Purpose | Notes |
|---|---|---|
| `config_get` | Show current session configuration | Includes runtime path and counters |
| `config_set` | Set session runtime path | Connection-scoped |
| `config_reset` | Reset runtime path and build state | Keeps extension loaded |
| `tcc_new_state` | Start a fresh build state | Drops staged build inputs |
| `list` | Show session registry/build counters | Diagnostics only |

### Build Inputs

| Mode | Purpose |
|---|---|
| `add_include`, `add_sysinclude` | Add include paths |
| `add_library_path`, `add_library` | Add library paths/libraries |
| `add_option`, `add_define` | Add compiler flags and defines |
| `add_header`, `add_source` | Stage C code units in session |
| `tinycc_bind` | Stage `symbol` + `sql_name` for next compile |

### Compile and Register

| Mode | Purpose | Notes |
|---|---|---|
| `compile` | Compile staged session code and register SQL UDF | Uses `tinycc_bind` or explicit `symbol`/`sql_name` |
| `quick_compile` | One-shot fast lane compile + register | Requires `source`, `symbol`, `sql_name`, `return_type`, `arg_types`; optional `wrapper_mode := 'row'|'batch'`; can also pass per-call `include_path`, `sysinclude_path`, `library_path`, `library`, `option`, `define_*`, `header` |
| `codegen_preview` | Generate wrapper C source only (no compile/relocate/register) | Uses same signature inputs as compile path (including `wrapper_mode`); returns generated C in `detail` |

### Discovery Helpers

| Function | Purpose | Notes |
|---|---|---|
| `tcc_system_paths(runtime_path := '', library_path := '')` | Show include and library search paths used by TinyCC workflows | Includes existence flags; includes Windows/MSYS2/Rtools defaults on Windows builds |
| `tcc_library_probe(library := ..., runtime_path := '', library_path := '')` | Resolve a library short name or full filename/path | Supports `.a`, `.so*`, `.dylib`, `.dll`, `.lib` style names |

## Supported Types

Type metadata is explicit for `compile`, `quick_compile`, and `codegen_preview`:

- `return_type := ...` is required
- `arg_types := [...]` is required (use `[]` for zero arguments)

Current executable SQL registration support:

| Signature Piece | Accepted Tokens | DuckDB Type |
|---|---|---|
| `return_type` | `void`, `bool`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `f32`, `f64`, `varchar`, `text`, `string`, `cstring`, `blob`, `bytea`, `binary`, `varbinary`, `buffer`, `bytes`, `uuid`, `date`, `time`, `timestamp`, `interval`, `decimal`, `numeric` | `BIGINT` for `void`; otherwise matching scalar type |
| each `arg_types` element | same scalar tokens as `return_type`, plus fixed-child list tokens `list_i64` or `i64[]`, fixed-size array tokens like `i64[3]`, `struct<name:type;...>`, and `map<key_type;value_type>` | scalar type, `LIST(child)`, `ARRAY(child,N)`, `STRUCT(...)`, or `MAP(...)` |

Additional limits and behavior:

- Arity: `0..N` arguments (no fixed hard-coded cap)
- Wrapper mode: `row` (default) or `batch`
- NULL handling: NULL-in/NULL-out
- `void` return registers as a SQL function that emits `NULL` values
- `varchar`/`cstring` bridge to C `const char *`; returned `NULL` pointers produce SQL `NULL`
- `blob`/`buffer` bridge to C `ducktinycc_blob_t { const void *ptr; uint64_t len }`; returned `ptr == NULL` produces SQL `NULL`
- easy scalar structs use C aliases: `ducktinycc_hugeint_t` (UUID), `ducktinycc_date_t`, `ducktinycc_time_t`, `ducktinycc_timestamp_t`, `ducktinycc_interval_t`, `ducktinycc_decimal_t`
- list arguments bridge to C `ducktinycc_list_t { const void *ptr; const uint64_t *validity; uint64_t offset; uint64_t len }`
- list returns are supported via `ducktinycc_list_t` (`ptr == NULL` yields SQL `NULL`)
- fixed-size array arguments/returns use `ducktinycc_array_t { const void *ptr; const uint64_t *validity; uint64_t offset; uint64_t len }`
- struct arguments/returns use `ducktinycc_struct_t { const void *const *field_ptrs; const uint64_t *const *field_validity; uint64_t field_count; uint64_t offset }`
- map arguments/returns use `ducktinycc_map_t { key_ptr, key_validity, value_ptr, value_validity, offset, len }`
- `i64[]` means variable-length `LIST`; `i64[3]` means fixed-size `ARRAY`
- current `struct<...>` and `map<...>` members support fixed-width scalar families only (`bool/i8/u8/i16/u16/i32/u32/i64/u64/f32/f64/uuid/date/time/timestamp/interval/decimal`)
- `struct<...>` and `map<...>` use `;` separators in tokens to avoid ambiguity inside `arg_types := [...]`
- `decimal`/`numeric` currently bind as `DECIMAL(18,3)`

## How It Works

- `compile`, `quick_compile`, and `codegen_preview` generate C wrapper code around the target `symbol`.
- `wrapper_mode := 'row'` generates a row ABI wrapper (`void **args`, `out_value`, `out_is_null`).
- `wrapper_mode := 'batch'` generates a chunk ABI wrapper (`arg_data`, validity masks, `count`, output buffer/mask) and runs once per DuckDB chunk.
- A generated module init function calls `ducktinycc_register_signature(...)` to register the SQL scalar UDF in the active DuckDB connection.
- TinyCC compile + relocate is fully in-memory (no shared library file is emitted).
- Host symbols injected into each TinyCC state are currently fixed: `duckdb_ext_api` and `ducktinycc_register_signature`.
- DuckDB still owns all vectors/buffers; wrappers operate on borrowed chunk memory and should not retain pointers past the call.
- VARCHAR inputs are read from DuckDB `duckdb_string_t` vectors and passed to wrappers as C `const char *`.
- BLOB inputs are presented as `ducktinycc_blob_t` views over DuckDB buffers.
- LIST inputs are presented as `ducktinycc_list_t` slices over DuckDB child vectors (`ptr` + `len` + validity bitmask + child offset).
- ARRAY inputs are presented as `ducktinycc_array_t` fixed-size slices over DuckDB array child vectors.
- STRUCT inputs are presented as `ducktinycc_struct_t` views over struct child vectors.
- MAP inputs are presented as `ducktinycc_map_t` slices over map key/value child vectors.

## Memory Ownership and Lifecycle

- Input argument memory is borrowed from DuckDB vectors for the duration of a scalar callback only.
- Output memory is DuckDB-managed; wrappers write directly into DuckDB output buffers.
- VARCHAR outputs are copied into DuckDB-owned storage with `duckdb_vector_assign_string_element`.
- BLOB outputs are copied into DuckDB-owned storage with `duckdb_vector_assign_string_element_len`.
- Host-side marshalling scratch buffers (`arg_ptrs`, decoded column arrays, list descriptors) are allocated with `duckdb_malloc` and freed before callback return.
- Compiled code and symbols live inside each TinyCC relocated state (`TCCState`) and are released when that artifact is destroyed.
- `config_reset` and `tcc_new_state` clear staged build/session inputs, but do not remove already registered SQL UDF catalog entries.
- Current DuckDB C API behavior treats these API-registered scalar functions as internal catalog entries, so SQL `DROP FUNCTION` is not available for them.

## Design Direction (API Still Evolving)

- Host symbol registration mode: feasible and aligned with Rtinycc-style embedding; prefer an allow-listed registry (name -> host address) over raw SQL-provided addresses.
- Arrow to reduce marshalling: not used directly; batch wrappers already consume DuckDB vectors column-wise and avoid per-row host-wrapper crossings.
- DuckDB nested types: `LIST`, `ARRAY`, `STRUCT`, and `MAP` are first-class SQL argument/return tokens with C descriptors; nested/non-fixed-width struct/map members remain future work.
- Pointer utilities (next): adopt an Rtinycc-like helper layer for typed memory I/O (`read_i8/u8/.../f64/ptr`, `write_*`, `read_bytes`, `write_bytes`) on opaque pointer handles.
- Pointer representation: use `UBIGINT` handles in SQL mapped to an internal pointer registry with ownership tags (`owned`, `borrowed`, `external`) and optional type tags.
- Real C structs (not DuckDB `STRUCT`): treat these as pointer-backed objects (`ptr<T>` style), with helper UDFs for `malloc/free`, field address, `container_of`, and typed field get/set/read/write.
- Safety posture: no raw user-provided addresses by default; pointers should enter through controlled constructors/host symbols and be validated through the registry.

## Builds

```sh
make configure
make debug  # debug
make release # release
```

## Test

```sh
make test_debug
make test_release
```

## Examples

Run these snippets in one DuckDB shell session (`duckdb -unsigned`) with timing
enabled.

### 1) Setup

```sh
duckdb -unsigned
.timer on
LOAD 'build/release/ducktinycc.duckdb_extension';
```

### 2) Session Configuration

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'config_set',
  runtime_path := ''
);

SELECT ok, mode, code, detail
FROM tcc_module(mode := 'config_get');

SELECT ok, mode, code, detail
FROM tcc_module(mode := 'list');
SQL
```

### 3) System Paths and Library Probe Helpers

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT kind, key, exists, value
FROM tcc_system_paths()
LIMIT 12;

SELECT kind, key, exists, value, detail
FROM tcc_library_probe(library := 'libtcc1.a');
SQL
```

### 4) Example A: Staged Build + `tinycc_bind` + `compile`

This example stages shared build inputs once, compiles two symbols, and calls both SQL functions.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'tcc_new_state');
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_include',
  include_path := 'third_party/tinycc/include'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_sysinclude',
  sysinclude_path := 'third_party/tinycc/include'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_library_path',
  library_path := 'third_party/tinycc'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_option',
  option := '-O2'
);
SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_define',
  define_name := 'TCC_SHIFT',
  define_value := '3'
);

SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_header',
  header := '#include <stdint.h>'
);

SELECT ok, mode, code, detail
FROM tcc_module(
  mode := 'add_source',
  source := '
    long long tcc_add_shift(long long x){ return x + TCC_SHIFT; }
    long long tcc_times2(long long x){ return x * 2; }
  '
);

SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_add_shift', sql_name := 'tcc_add_shift');
SELECT ok, mode, code
FROM tcc_module(
  mode := 'compile',
  return_type := 'i64',
  arg_types := ['i64']
);
SELECT tcc_add_shift(39) AS value;

SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_bind', symbol := 'tcc_times2', sql_name := 'tcc_times2');
SELECT ok, mode, code
FROM tcc_module(
  mode := 'compile',
  return_type := 'i64',
  arg_types := ['i64']
);
SELECT tcc_times2(21) AS value;
SQL
```

### 5) Example B: Fast Lane `quick_compile` (with include/library inputs)

This example compiles and registers directly from one SQL call, including
`include_path`, `library_path`, and `library`.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := '#include <math.h>
double qpow(double x, double y){ return pow(x, y); }',
  symbol := 'qpow',
  sql_name := 'qpow',
  return_type := 'f64',
  arg_types := ['f64', 'f64'],
  include_path := 'third_party/tinycc/include',
  library_path := 'third_party/tinycc',
  library := 'm'
);
SELECT CAST(qpow(2.0, 5.0) AS BIGINT) AS value;
SQL
```

### 6) Example C: Libraries (`add_library`)

This example links `libm`, compiles a function that uses `pow`, then calls it.
The required C header is included in the source unit.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(mode := 'tcc_new_state');
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_library',
  library := 'm'
);
SELECT ok, mode, code
FROM tcc_module(
  mode := 'add_source',
  source := '#include <math.h>
double pwr(double x, double y){ return pow(x, y); }'
);
SELECT ok, mode, code
FROM tcc_module(mode := 'tinycc_bind', symbol := 'pwr', sql_name := 'pwr');
SELECT ok, mode, code
FROM tcc_module(mode := 'compile', return_type := 'f64', arg_types := ['f64', 'f64']);
SELECT CAST(pwr(2.0, 5.0) AS BIGINT) AS value;
SQL
```

### 7) Reset Session

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'list');
SELECT ok, mode, code
FROM tcc_module(mode := 'config_reset');
SQL
```

### 8) Codegen Preview (No Compile)

This shows generated wrapper/module-init source without compiling or registering
the SQL function.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, phase, code, artifact_id, LEFT(detail, 220) AS preview
FROM tcc_module(
  mode := 'codegen_preview',
  source := 'int add_i32(int a, int b){ return a + b; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32'],
  wrapper_mode := 'batch'
);
SQL
```

### 9) Batch Wrapper Mode

Use `wrapper_mode := 'batch'` to generate a chunk-oriented wrapper and invoke it
once per DuckDB chunk.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long batch_add(long long a, long long b){ return a + b; }',
  symbol := 'batch_add',
  sql_name := 'batch_add',
  return_type := 'i64',
  arg_types := ['i64', 'i64'],
  wrapper_mode := 'batch'
);
SELECT CAST(SUM(batch_add(i, 2)) AS BIGINT) AS s
FROM range(1000000) AS t(i);
SQL
```

### 10) Arrays/Lists as C Slice Arguments

For list arguments, wrappers pass a C slice descriptor:

- `ptr`: pointer to first child element for this row
- `len`: element count
- `offset`: child-vector global offset
- `validity`: child-vector validity mask (or `NULL` when all valid)

`ducktinycc_list_is_valid(&list, i)` is available in generated code for child NULL checks.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_i64(ducktinycc_list_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_list_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_i64',
  sql_name := 'sum_i64',
  return_type := 'i64',
  arg_types := ['i64[]'],
  wrapper_mode := 'batch'
);
SELECT sum_i64([1,2,3]::BIGINT[]) AS sum_plain;
SELECT sum_i64([1,NULL,3]::BIGINT[]) AS sum_with_null_child;
SQL
```

Fixed-size arrays use `type[N]` and `ducktinycc_array_t`:

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long sum_array3(ducktinycc_array_t a){
  const long long *p = (const long long *)a.ptr;
  unsigned long long i;
  long long s = 0;
  if (!a.ptr) return 0;
  for (i = 0; i < a.len; i++) {
    if (ducktinycc_array_is_valid(&a, i)) s += p[i];
  }
  return s;
}',
  symbol := 'sum_array3',
  sql_name := 'sum_array3',
  return_type := 'i64',
  arg_types := ['i64[3]']
);
SELECT sum_array3([1,2,3]::BIGINT[3]) AS sum_plain;
SELECT sum_array3([1,NULL,3]::BIGINT[3]) AS sum_with_null_child;
SQL
```

Structs use `struct<name:type;...>` and `ducktinycc_struct_t`:

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long struct_sum2(ducktinycc_struct_t s){
  const long long *a;
  const long long *b;
  if (!s.field_ptrs || s.field_count < 2) return 0;
  a = (const long long *)ducktinycc_struct_field_ptr(&s, 0);
  b = (const long long *)ducktinycc_struct_field_ptr(&s, 1);
  return (a && ducktinycc_struct_field_is_valid(&s, 0) ? a[s.offset] : 0) +
         (b && ducktinycc_struct_field_is_valid(&s, 1) ? b[s.offset] : 0);
}',
  symbol := 'struct_sum2',
  sql_name := 'struct_sum2',
  return_type := 'i64',
  arg_types := ['struct<a:i64;b:i64>']
);
SELECT struct_sum2({'a': 2::BIGINT, 'b': 5::BIGINT}::STRUCT(a BIGINT, b BIGINT)) AS s;
SQL
```

Maps use `map<key_type;value_type>` and `ducktinycc_map_t`:

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'long long map_sum(ducktinycc_map_t m){
  const long long *k = (const long long *)m.key_ptr;
  const long long *v = (const long long *)m.value_ptr;
  unsigned long long i;
  long long out = 0;
  if (!m.key_ptr || !m.value_ptr) return 0;
  for (i = 0; i < m.len; i++) {
    if (ducktinycc_map_key_is_valid(&m, i) && ducktinycc_map_value_is_valid(&m, i)) out += k[i] + v[i];
  }
  return out;
}',
  symbol := 'map_sum',
  sql_name := 'map_sum',
  return_type := 'i64',
  arg_types := ['map<i64;i64>']
);
SELECT map_sum(MAP([1::BIGINT,2::BIGINT],[10::BIGINT,20::BIGINT])::MAP(BIGINT, BIGINT)) AS s;
SQL
```

### 11) `config_reset` Semantics

`config_reset` clears runtime/build staging state, but does not remove already
registered SQL UDF catalog entries.

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
LOAD 'build/release/ducktinycc.duckdb_extension';
.timer on
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int reset_demo(int x){ return x + 1; }',
  symbol := 'reset_demo',
  sql_name := 'reset_demo',
  return_type := 'i32',
  arg_types := ['i32']
);
SELECT reset_demo(41) AS before_reset;

SELECT ok, mode, code
FROM tcc_module(mode := 'config_reset');
SELECT ok, mode, code, detail
FROM tcc_module(mode := 'list');

SELECT reset_demo(41) AS after_reset;
SQL
```

### 12) CLI Benchmark Snippet

Use the DuckDB CLI timer to benchmark compile and call latency quickly:

```{bash eval=TRUE, collapse=FALSE, comment=""}
duckdb -unsigned <<'SQL'
.timer on
LOAD 'build/release/ducktinycc.duckdb_extension';
SELECT ok, mode, code
FROM tcc_module(
  mode := 'quick_compile',
  source := 'int add_i32(int a, int b){ return a + b; }',
  symbol := 'add_i32',
  sql_name := 'add_i32',
  return_type := 'i32',
  arg_types := ['i32', 'i32']
);
SELECT add_i32(20, 22);
SELECT SUM(add_i32(i::INTEGER, 42::INTEGER)) AS s FROM range(1000000) t(i);
SELECT SUM(add_i32(i::INTEGER, 42::INTEGER)) AS s FROM range(1000000) t(i);
SELECT SUM(add_i32(i::INTEGER, 42::INTEGER)) AS s FROM range(1000000) t(i);
SQL
```

### 13) Cleanup

No explicit cleanup is required in the CLI example flow.

## Notes

- Function invocation is plain SQL (`SELECT my_udf(...)`) after `compile` or `quick_compile`.
- `add_header`/`add_source` are compiled as separate translation units. For external library prototypes, include headers directly in the relevant `source` unit.
- Use `tcc_system_paths()` and `tcc_library_probe()` to diagnose platform-specific library resolution (including Windows/Rtools/MSYS2 layouts).
- All outputs are returned as a diagnostics table for SQL-native observability.
